# Idefix - solution

Save the location of the trees with their indexes. This allows for the creation of a triangulation where each vertex has its own index. Using the edge iterator found in the file _emst.cpp_ that allows to extract edges described by vertex indexes from the edges of the triangulation, create two arrays, one containing all the edges covered by the task 1 shadows (it must be $sqLength \leq 4 \cdot r^2$) and the other containing all the edges.

Iterating through all the bones, find how many bones are covered by each tree in task 1. First, find the nearest tree in the triangulation and its distance; then, a bone is covered by that tree if $sqDistance \leq shadowRadius$. There is no problem if a bone is covered by two shadows and that bone is counted only by the nearest tree. If that's the case, the trees are in the same connected component anyway. At the same time, save each bone with its distance to the nearest tree.

Build a BGL graph containing the edges covered by the shadow of task 1. Find the connected components of that graph. For each tree, add the number of bones covered by that tree to the bones covered by the connected component that it is part of. At the end, find the connected component with the most bones covered.

For task 2, order all bones by their distance to the nearest tree and all edges by their length. Create an array that will contain all the bones in the connected components that will be created using disjointed sets. The starting number of disjointed sets (and therefore of connected components) is $n$, the number of trees. Then, in a loop:
- If there are still bones, update $q$ taking the first of the remaining bones and its distance to the nearest tree. Add 1 to the number of bones covered by the connected component that contains that tree (using `find_set`). If that connected component has at least $k$ bones, exit.
- Add all the edges such that $squaredLength \leq 4 \cdot NextBoneMinDistance$, where $NextBoneMinDistance$ is the distance to the nearest tree of the next bone that would be considered in the first phase of this loop. If there are no more bones, just add edges. For each edge, connect the two connected components of its nodes, if not already connected. Where there is a new connection, update the number of bones inside each one of the two starting connected components by summing the starting values (it's necessary to update both because itâ€™s not known which one will be inserted in which one). If the newly connected component has at least $k$ bones, exit.

As a side note, keep in mind that, even if this problem has two tasks, it's possible to get half the points just by doing the first task because the first two sets of tests have, in their description, the answer for the second task.